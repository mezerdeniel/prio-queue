/*
 * Project and Training 2 - HS23, Computer Science, Berner Fachhochschule
 */

// You are not allowed to change this file.

package ch.bfh.queue;

import ch.bfh.basics.Locator;
import ch.bfh.exceptions.EmptyPriorityQueueException;
import ch.bfh.exceptions.InvalidLocatorException;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

class PrintlnTest {

	private final ByteArrayOutputStream outStream = new ByteArrayOutputStream();
	private final ByteArrayOutputStream errStream = new ByteArrayOutputStream();
	private final PrintStream originalOutStream = System.out;
	private final PrintStream originalErrStream = System.err;
	private static final Comparator<Integer> INT_COMPARATOR = Comparator.naturalOrder();


	@BeforeEach
	public void setUpStreams() {
		System.setOut(new PrintStream(outStream));
		System.setErr(new PrintStream(errStream));
	}

	@AfterEach
	public void restoreStreams() {
		System.setOut(originalOutStream);
		System.setErr(originalErrStream);
	}

	@Test
	public void isEmpty() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.isEmpty();
		assertEquals("", outStream.toString(), "Method isEmpty() should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method isEmpty() should not generate any output on stderr");
	}

	@Test
	public void testSize() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.size();
		assertEquals("", outStream.toString(), "Method size() should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method size() should not generate any output on stderr");
	}

	@Test
	public void testClear() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.clear();
		assertEquals("", outStream.toString(), "Method clear() should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method clear() should not generate any output on stderr");
	}


	@Test
	public void testInsert() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.insert(1, "A");
		assertEquals("", outStream.toString(), "Method insert(k, e) should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method  insert(k, e) should not generate any output on stderr");
	}

	@Test
	public void testRemoveMin() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.insert(1, "A");
		pq.removeMin();
		assertEquals("", outStream.toString(), "Method removeMin() on a non-empty priority queue should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method removeMin() on a non-empty priority queue should not generate any output on stderr");
	}

	@Test
	public void testRemoveMin2() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		assertThrows(EmptyPriorityQueueException.class, pq::removeMin);
		assertEquals("", outStream.toString(), "Method removeMin() on an empty priority queue should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testMinKey() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.insert(1, "A");
		pq.minKey();
		assertEquals("", outStream.toString(), "Method minKey() on a non-empty priority queue should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method minKey() on a non-empty priority queue should not generate any output on stderr");
	}

	@Test
	public void testMinKey2() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		assertThrows(EmptyPriorityQueueException.class, pq::minKey);
		assertEquals("", outStream.toString(), "Method minKey() on an empty priority queue should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testMinElement() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.insert(1, "A");
		pq.minElement();
		assertEquals("", outStream.toString(), "Method minKey() on a non-empty priority queue should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method minKey() on a non-empty priority queue should not generate any output on stderr");
	}

	@Test
	public void testMinElement2() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		assertThrows(EmptyPriorityQueueException.class, pq::minElement);
		assertEquals("", outStream.toString(), "Method minElement() on an empty priority queue should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testReplaceKey() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		Locator l = pq.insert(1, "A");
		pq.replaceKey(l, 2);
		assertEquals("", outStream.toString(), "Method replaceKey() on a valid locator should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method replaceKey() on a valid locator should not generate any output on stderr");
	}

	@Test
	public void testReplaceKey2() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		assertThrows(InvalidLocatorException.class, () -> pq.replaceKey(null, 2));
		assertEquals("", outStream.toString(), "Method replaceKey() on an invalid locator should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testReplaceKey3() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		Locator l = pq.insert(1, "A");
		pq.remove(l);
		assertThrows(InvalidLocatorException.class, () -> pq.replaceKey(l, 2));
		assertEquals("", outStream.toString(), "Method replaceKey() on an invalid locator queue should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}


	@Test
	public void testReplaceElement() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		Locator l = pq.insert(1, "A");
		pq.replaceElement(l, "B");
		assertEquals("", outStream.toString(), "Method replaceElement() on a valid locator should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method replaceElement() on a valid locator should not generate any output on stderr");
	}

	@Test
	public void testReplaceElement2() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		assertThrows(InvalidLocatorException.class, () -> pq.replaceElement(null, "2"));
		assertEquals("", outStream.toString(), "Method replaceElement() on an invalid locator should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testReplaceElement3() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		Locator l = pq.insert(1, "A");
		pq.remove(l);
		assertThrows(InvalidLocatorException.class, () -> pq.replaceElement(l, "2"));
		assertEquals("", outStream.toString(), "Method replaceElement() on an invalid locator should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}



	@Test
	public void testRemove() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		Locator l = pq.insert(1, "A");
		pq.remove(l);
		assertEquals("", outStream.toString(), "Method remove() on a valid locator should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method remove() on a valid locator should not generate any output on stderr");
	}

	@Test
	public void testRemove2() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		assertThrows(InvalidLocatorException.class, () -> pq.remove(null));
		assertEquals("", outStream.toString(), "Method remove() on an invalid locator should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testRemove3() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		Locator l = pq.insert(1, "A");
		pq.remove(l);
		assertThrows(InvalidLocatorException.class, () -> pq.remove(l));
		assertEquals("", outStream.toString(), "Method remove() on an invalid locator should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}


	@Test
	public void testKey() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		Locator l = pq.insert(1, "A");
		pq.key(l);
		assertEquals("", outStream.toString(), "Method key() on a valid locator should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method key() on a valid locator should not generate any output on stderr");
	}

	@Test
	public void testKey2() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		assertThrows(InvalidLocatorException.class, () -> pq.key(null));
		assertEquals("", outStream.toString(), "Method key() on an invalid locator should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testKey3() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		Locator l = pq.insert(1, "A");
		pq.remove(l);
		assertThrows(InvalidLocatorException.class, () -> pq.key(l));
		assertEquals("", outStream.toString(), "Method key() on an invalid locator should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testElement() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		Locator l = pq.insert(1, "A");
		pq.element(l);
		assertEquals("", outStream.toString(), "Method key() on a valid locator should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method key() on a valid locator should not generate any output on stderr");
	}

	@Test
	public void testElement2() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		assertThrows(InvalidLocatorException.class, () -> pq.element(null));
		assertEquals("", outStream.toString(), "Method key() on an invalid locator should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testElement3() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		Locator l = pq.insert(1, "A");
		pq.remove(l);
		assertThrows(InvalidLocatorException.class, () -> pq.element(l));
		assertEquals("", outStream.toString(), "Method key() on an invalid locator should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testGetComparator() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.getComparator();
		assertEquals("", outStream.toString(), "Method getComparator() on an empty priority queue should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method getComparator() on an empty priority queue should not generate any output on stderr");
	}

	@Test
	public void testGetComparator2() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.insert(1, "A");
		pq.getComparator();
		assertEquals("", outStream.toString(), "Method getComparator() on a non-empty priority queue should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method getComparator() on a non-empty priority queue should not generate any output on stderr");
	}

	@Test
	public void testSetComparator() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.setComparator(INT_COMPARATOR.reversed());
		assertEquals("", outStream.toString(), "Method setComparator() on an empty priority queue should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method setComparator() on an empty priority queue should not generate any output on stderr");
	}

	@Test
	public void testSetComparator2() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.insert(1, "A");
		pq.setComparator(INT_COMPARATOR.reversed());
		assertEquals("", outStream.toString(), "Method setComparator() on a non-empty priority queue should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method setComparator() on a non-empty priority queue should not generate any output on stderr");
	}

	@Test
	public void testSetComparator3() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.insert(1, "A");
		pq.insert(1, "A");
		pq.insert(1, "A");
		pq.insert(1, "A");
		pq.setComparator(INT_COMPARATOR.reversed());
		assertEquals("", outStream.toString(), "Method setComparator() on a non-empty priority queue should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method setComparator() on a non-empty priority queue should not generate any output on stderr");
	}

	@Test
	public void testKeys() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.insert(1, "A");
		pq.insert(2, "B");
		pq.insert(3, "C");
		pq.insert(4, "D");
		Iterator<Integer> iter = pq.keys();
		while (iter.hasNext()) {
			iter.next();
		}
		assertEquals("", outStream.toString(), "Method keys() and successful iteration on a non-empty priority queue should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method keys() and successful iteration on a non-empty priority queue should not generate any output on stderr");
	}

	@Test
	public void testElements() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		pq.insert(1, "A");
		pq.insert(2, "B");
		pq.insert(3, "C");
		pq.insert(4, "D");
		Iterator<String> iter = pq.elements();
		while (iter.hasNext()) {
			iter.next();
		}
		assertEquals("", outStream.toString(), "Method elements() and successful iteration on a non-empty priority queue should not generate any output on stdout");
		assertEquals("", errStream.toString(), "Method elements() and successful iteration on a non-empty priority queue should not generate any output on stderr");
	}

	@Test
	public void testKeysEnd() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		assertThrows(NoSuchElementException.class, () -> pq.keys().next());
		assertEquals("", outStream.toString(),"exception generated by next in an iteration should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

	@Test
	public void testElementsEnd() {
		PriorityQueue<Integer, String> pq = new HeapBasedPriorityQueue<>(INT_COMPARATOR);
		assertThrows(NoSuchElementException.class, () -> pq.elements().next());
		assertEquals("", outStream.toString(),"exception generated by next in an iteration should not generate any output on stdout");
		// Output on stderr might be generated by the exception
	}

}
